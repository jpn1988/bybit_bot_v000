#!/usr/bin/env python3
"""
Orchestrateur principal du bot Bybit.

‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                    üìñ GUIDE DE LECTURE                            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Ce fichier est l'ORCHESTRATEUR PRINCIPAL du bot. Il coordonne tous
les composants sp√©cialis√©s pour d√©marrer et maintenir le bot en vie.

üîç COMPRENDRE CE FICHIER EN 5 MINUTES :

1. __init__() (lignes 52-91) : Initialise tous les managers
   ‚îî‚îÄ> Cr√©e les helpers : initializer, configurator, starter, etc.

2. start() (lignes 110-163) : S√©quence de d√©marrage en 7 √©tapes
   ‚îú‚îÄ> Charge la configuration (parameters.yaml + ENV)
   ‚îú‚îÄ> R√©cup√®re les donn√©es de march√© via API
   ‚îú‚îÄ> Configure les managers
   ‚îú‚îÄ> Construit la watchlist (avec filtres)
   ‚îú‚îÄ> Affiche le r√©sum√©
   ‚îú‚îÄ> D√©marre les composants (WebSocket, monitoring, affichage)
   ‚îî‚îÄ> Entre dans la boucle de surveillance

3. _keep_bot_alive() (lignes 165-195) : Boucle principale
   ‚îî‚îÄ> V√©rifie la sant√© des composants toutes les secondes

4. stop() (lignes 218-242) : Arr√™t propre du bot
   ‚îî‚îÄ> Utilise ShutdownManager pour tout arr√™ter proprement

üìö FLUX D√âTAILL√â : Consultez GUIDE_DEMARRAGE_BOT.md pour comprendre
   chaque √©tape en d√©tail avec des diagrammes et explications.

üéØ COMPOSANTS UTILIS√âS :
- BotInitializer : Initialisation des managers
- BotConfigurator : Configuration du bot
- DataManager : Gestion des donn√©es
- BotStarter : D√©marrage des composants
- BotHealthMonitor : Surveillance de la sant√©
- ShutdownManager : Gestion de l'arr√™t
- ThreadManager : Gestion des threads
"""

import asyncio
import signal
import sys
import time
import atexit
from typing import Dict, Any
from logging_setup import setup_logging

from config import get_settings
from http_client_manager import close_all_http_clients
from metrics_monitor import start_metrics_monitoring
from bybit_client import BybitClient

# Import des composants refactoris√©s
from bot_initializer import BotInitializer
from bot_configurator import BotConfigurator
from data_manager import DataManager
from bot_starter import BotStarter
from bot_health_monitor import BotHealthMonitor
from shutdown_manager import ShutdownManager
from thread_manager import ThreadManager
from scheduler_manager import SchedulerManager
from position_monitor import PositionMonitor
from funding_close_manager import FundingCloseManager
from thread_exception_handler import install_global_exception_handlers, install_asyncio_handler_if_needed


class BotOrchestrator:
    """
    Orchestrateur principal du bot Bybit.

    Cette classe coordonne les diff√©rents composants sp√©cialis√©s :
    - BotInitializer : Initialisation des managers
    - BotConfigurator : Configuration du bot
    - DataManager : Gestion des donn√©es
    - BotStarter : D√©marrage des composants
    - BotHealthMonitor : Surveillance de la sant√©
    - ShutdownManager : Gestion de l'arr√™t
    - ThreadManager : Gestion des threads
    """

    def __init__(
        self,
        logger=None,
        initializer=None,
        configurator=None,
        data_loader=None,
        starter=None,
        health_monitor=None,
        shutdown_manager=None,
        thread_manager=None,
    ):
        """
        Initialise l'orchestrateur du bot.
        
        Args:
            logger: Logger pour les messages (optionnel)
            initializer: Initialiseur du bot (optionnel, cr√©√© automatiquement si non fourni)
            configurator: Configurateur du bot (optionnel, cr√©√© automatiquement si non fourni)
            data_loader: Gestionnaire de donn√©es (optionnel, cr√©√© automatiquement si non fourni)
            starter: D√©marreur du bot (optionnel, cr√©√© automatiquement si non fourni)
            health_monitor: Moniteur de sant√© (optionnel, cr√©√© automatiquement si non fourni)
            shutdown_manager: Gestionnaire d'arr√™t (optionnel, cr√©√© automatiquement si non fourni)
            thread_manager: Gestionnaire de threads (optionnel, cr√©√© automatiquement si non fourni)
        """
        self.logger = logger or setup_logging()
        self.running = True

        # Installer les handlers globaux pour exceptions non captur√©es
        # IMPORTANT : √Ä faire avant de cr√©er des threads ou t√¢ches asyncio
        install_global_exception_handlers(self.logger)

        # S'assurer que les clients HTTP sont ferm√©s √† l'arr√™t
        atexit.register(close_all_http_clients)

        # Configuration
        settings = get_settings()
        self.testnet = settings["testnet"]
        
        # Test de connexion Bybit authentifi√©e (ex√©cut√© dans un thread d√©di√© pour √©viter PERF-002)
        self._test_bybit_auth_connection_sync()

        # Initialiser les composants sp√©cialis√©s (injection avec fallback)
        self._initializer = initializer or BotInitializer(self.testnet, self.logger)
        self._configurator = configurator or BotConfigurator(self.testnet, self.logger)
        self._data_loader = data_loader or DataManager(self.testnet, self.logger)
        self._starter = starter or BotStarter(self.testnet, self.logger)
        self._health_monitor = health_monitor or BotHealthMonitor(self.logger)

        # Initialiser les nouveaux managers
        self._shutdown_manager = shutdown_manager or ShutdownManager(self.logger)
        self._thread_manager = thread_manager or ThreadManager(self.logger)
        # Scheduler sera initialis√© avec la configuration dans start()
        self.scheduler = None
        
        # PositionMonitor pour surveiller les positions
        self.position_monitor = None
        self.funding_close_manager = None

        # Initialiser les managers via l'initialiseur
        self._initialize_components()

        # Configuration du signal handler pour Ctrl+C via ShutdownManager
        self._shutdown_manager.setup_signal_handler(self)

        # Initialiser le temps de d√©marrage pour l'uptime
        self.start_time = time.time()

        # D√©marrer le monitoring des m√©triques
        start_metrics_monitoring(interval_minutes=5)

        # Stocker la r√©f√©rence au moniteur de m√©triques pour l'arr√™t
        from metrics_monitor import metrics_monitor
        self.metrics_monitor = metrics_monitor

    # ============================================================================
    # M√âTHODES D'INITIALISATION
    # ============================================================================

    def _initialize_components(self):
        """Initialise tous les composants du bot."""
        # Initialiser les managers
        self._initializer.initialize_managers()
        self._initializer.initialize_specialized_managers()
        self._initializer.setup_manager_callbacks()

        # R√©cup√©rer les managers depuis l'initialiseur
        managers = self._initializer.get_managers()
        self.data_manager = managers["data_manager"]
        self.display_manager = managers["display_manager"]
        self.monitoring_manager = managers["monitoring_manager"]
        self.ws_manager = managers["ws_manager"]
        self.volatility_tracker = managers["volatility_tracker"]
        self.watchlist_manager = managers["watchlist_manager"]
        self.callback_manager = managers["callback_manager"]
        self.opportunity_manager = managers["opportunity_manager"]

    def _test_bybit_auth_connection_sync(self) -> bool:
        """
        Teste la connexion √† l'API Bybit avec authentification compl√®te.
        V√©rifie les cl√©s BYBIT_API_KEY/BYBIT_API_SECRET depuis .env
        et log le statut de la connexion.
        
        Utilise concurrent.futures.ThreadPoolExecutor pour ex√©cuter dans un thread d√©di√©
        et supprimer le warning PERF-002.
        """
        settings = get_settings()
        testnet = settings["testnet"]
        api_key = settings["api_key"]
        api_secret = settings["api_secret"]

        if not api_key or not api_secret:
            self.logger.warning("üîí Cl√©s API non configur√©es : connexion authentifi√©e d√©sactiv√©e.")
            return False

        try:
            # Ex√©cuter la logique synchrone dans un thread d√©di√© pour √©viter PERF-002
            def _sync_connection_test():
                self.bybit_client = BybitClient(
                    testnet=testnet,
                    timeout=settings["timeout"],
                    api_key=api_key,
                    api_secret=api_secret,
                )
                return self.bybit_client.get_wallet_balance(account_type="UNIFIED")
            
            # Utiliser concurrent.futures pour √©viter les probl√®mes d'event loop
            import concurrent.futures
            with concurrent.futures.ThreadPoolExecutor() as executor:
                future = executor.submit(_sync_connection_test)
                result = future.result()
            
            balance = self._extract_usdt_balance(result)
            self.logger.info(f"‚úÖ Bybit connect√© ({'testnet' if testnet else 'mainnet'}) en mode authentifi√©. Balance : {balance} USDT")
            return True
        except Exception as e:
            self.logger.error(f"‚ùå V√©rification Bybit authentifi√©e √©chou√©e : {e}")
            return False

    def _extract_usdt_balance(self, wallet_response: dict) -> str:
        """
        Extrait le solde USDT de la r√©ponse de l'API Bybit.
        
        Args:
            wallet_response: R√©ponse brute de l'API get_wallet_balance
            
        Returns:
            str: Solde USDT format√© ou "N/A" si non trouv√©
        """
        try:
            # Structure r√©elle: list[0].totalWalletBalance ou list[0].coin[].walletBalance
            # L'API Bybit retourne directement { "list": [...] } sans wrapper "result"
            account_list = wallet_response.get("list", [])
            
            if not account_list:
                return "N/A"
            
            # Prendre le premier compte (g√©n√©ralement UNIFIED)
            account = account_list[0]
            
            # Essayer d'abord totalWalletBalance (solde total du portefeuille)
            total_balance = account.get("totalWalletBalance")
            
            if total_balance and total_balance != "0":
                return f"{float(total_balance):.2f}"
            
            # Sinon, chercher dans le tableau coin pour USDT
            coins = account.get("coin", [])
            
            for coin in coins:
                if coin.get("coin") == "USDT":
                    usdt_balance = coin.get("walletBalance", "0")
                    return f"{float(usdt_balance):.2f}"
            
            # Si aucun USDT trouv√©, retourner le solde total
            return f"{float(total_balance or 0):.2f}"
            
        except (ValueError, TypeError, KeyError, IndexError) as e:
            self.logger.debug(f"Erreur extraction solde USDT: {e}")
            return "N/A"

    # ============================================================================
    # M√âTHODES DE D√âMARRAGE
    # ============================================================================

    async def start(self):
        """D√©marre le suivi des prix avec filtrage par funding."""
        # Installer le handler asyncio pour la boucle √©v√©nementielle actuelle
        install_asyncio_handler_if_needed()
        
        try:
            # 1. Charger et valider la configuration
            config = self._configurator.load_and_validate_config(
                self.watchlist_manager.config_manager
            )
        except ValueError:
            return  # Arr√™t propre sans sys.exit

        try:
            # 2. R√©cup√©rer les donn√©es de march√©
            base_url, perp_data = self._configurator.get_market_data()
        except Exception as e:
            self.logger.error(f"‚ùå Erreur r√©cup√©ration donn√©es march√© : {e}")
            return

        # 3. Configurer les managers
        self._configurator.configure_managers(
            config,
            perp_data,
            self.data_manager,
            self.volatility_tracker,
            self.watchlist_manager,
            self.display_manager,
        )

        # 4. Charger les donn√©es de la watchlist
        if not self._data_loader.load_watchlist_data(
            base_url,
            perp_data,
            self.watchlist_manager,
            self.volatility_tracker,
        ):
            return

        # 5. Afficher le r√©sum√© de d√©marrage
        self._starter.display_startup_summary(
            config, perp_data, self.data_manager
        )

        # 6. D√©marrer tous les composants
        await self._starter.start_bot_components(
            self.volatility_tracker,
            self.display_manager,
            self.ws_manager,
            self.data_manager,
            self.monitoring_manager,
            base_url,
            perp_data,
        )

        # 7. Initialiser et d√©marrer le Scheduler pour la surveillance du funding
        self._initialize_scheduler(config)

        # 8. Initialiser le PositionMonitor
        self._initialize_position_monitor()
        
        # 9. Initialiser le FundingCloseManager
        self._initialize_funding_close_manager()
        
        # 10. D√©finir le callback du scheduler apr√®s l'initialisation
        if self.scheduler:
            self.scheduler.on_position_opened_callback = self._on_position_opened

        # 11. Maintenir le bot en vie avec une boucle d'attente
        await self._keep_bot_alive()

    def _initialize_scheduler(self, config):
        """Initialise le SchedulerManager pour la surveillance du funding."""
        funding_threshold = config.get('funding_threshold_minutes', 60)
        auto_trading_config = config.get('auto_trading', {})
        self.scheduler = SchedulerManager(
            self.logger, 
            funding_threshold, 
            bybit_client=self.bybit_client,
            auto_trading_config=auto_trading_config,
            on_position_opened_callback=None  # Sera d√©fini apr√®s
        )
        # Passer une fonction callback pour r√©cup√©rer les donn√©es √† jour
        asyncio.create_task(self.scheduler.run_with_callback(self._get_funding_data_for_scheduler))

    def _initialize_position_monitor(self):
        """
        Initialise le PositionMonitor avec les callbacks appropri√©s.
        """
        try:
            self.position_monitor = PositionMonitor(
                testnet=self.testnet,
                logger=self.logger,
                on_position_opened=self._on_position_opened,
                on_position_closed=self._on_position_closed
            )
            
            # D√©marrer le PositionMonitor
            self.position_monitor.start()
            
            self.logger.info("üîç PositionMonitor initialis√©")
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur initialisation PositionMonitor: {e}")
            self.position_monitor = None

    def _initialize_funding_close_manager(self):
        """Initialise le FundingCloseManager pour fermeture automatique apr√®s funding."""
        try:
            self.funding_close_manager = FundingCloseManager(
                testnet=self.testnet,
                logger=self.logger,
                bybit_client=self.bybit_client,
                on_position_closed=self._on_position_closed
            )
            self.funding_close_manager.start()
            self.logger.info("üí∞ FundingCloseManager initialis√©")
        except Exception as e:
            self.logger.error(f"‚ùå Erreur initialisation FundingCloseManager: {e}")
            self.funding_close_manager = None

    # ============================================================================
    # M√âTHODES DE CALLBACK POUR LES POSITIONS
    # ============================================================================

    def _on_position_opened(self, symbol: str, position_data: Dict[str, Any]):
        """
        Callback appel√© lors de l'ouverture d'une position.
        
        Args:
            symbol: Symbole de la position ouverte
            position_data: Donn√©es de la position
        """
        try:
            self.logger.info(f"üìà Position ouverte d√©tect√©e: {symbol}")
            
            # Ajouter la position active
            if self.monitoring_manager:
                self.monitoring_manager.add_active_position(symbol)
            
            # Basculer vers le symbole unique seulement si c'est la premi√®re position
            if self.ws_manager and len(self.monitoring_manager.get_active_positions()) == 1:
                self._switch_to_single_symbol(symbol)
            
            # Filtrer l'affichage vers le symbole unique
            if self.display_manager:
                self.display_manager.set_symbol_filter({symbol})
            
            # Ajouter la position √† la surveillance du funding
            if self.funding_close_manager:
                self.funding_close_manager.add_position_to_monitor(symbol)
            
            self.logger.info(f"‚è∏Ô∏è Watchlist en pause - Position ouverte sur {symbol}")
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur callback position ouverte: {e}")

    def _switch_to_single_symbol(self, symbol: str):
        """Bascule vers un symbole unique dans le WebSocket."""
        # D√©terminer la cat√©gorie du symbole
        category = "linear" if symbol.endswith("USDT") else "inverse"
        
        # Basculer vers le symbole unique (asynchrone)
        import asyncio
        asyncio.create_task(
            self.ws_manager.switch_to_single_symbol(symbol, category)
        )

    def _on_position_closed(self, symbol: str, position_data: Dict[str, Any]):
        """
        Callback appel√© lors de la fermeture d'une position.
        
        Args:
            symbol: Symbole de la position ferm√©e
            position_data: Donn√©es de la position
        """
        try:
            self.logger.info(f"üìâ Position ferm√©e d√©tect√©e: {symbol}")
            
            # Retirer la position active
            if self.monitoring_manager:
                self.monitoring_manager.remove_active_position(symbol)
            
            # Retirer aussi du scheduler
            if self.scheduler:
                self.scheduler.remove_position(symbol)
            
            # Restaurer la watchlist compl√®te seulement si plus de positions actives
            if (self.ws_manager and self.data_manager and 
                not self.monitoring_manager.has_active_positions()):
                self._restore_full_watchlist()
            
            # Restaurer l'affichage de tous les symboles
            if self.display_manager:
                self.display_manager.clear_symbol_filter()
            
            # Retirer la position de la surveillance du funding
            if self.funding_close_manager:
                self.funding_close_manager.remove_position_from_monitor(symbol)
            
            self.logger.info("‚ñ∂Ô∏è Watchlist reprise - Position ferm√©e")
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur callback position ferm√©e: {e}")

    def _restore_full_watchlist(self):
        """Restaure la watchlist compl√®te dans le WebSocket."""
        linear_symbols = self.data_manager.storage.get_linear_symbols()
        inverse_symbols = self.data_manager.storage.get_inverse_symbols()
        
        # Restaurer la watchlist compl√®te (asynchrone)
        import asyncio
        asyncio.create_task(
            self.ws_manager.restore_full_watchlist(linear_symbols, inverse_symbols)
        )

    # ============================================================================
    # M√âTHODES DE DONN√âES ET MONITORING
    # ============================================================================

    def _get_funding_data_for_scheduler(self) -> Dict[str, Dict[str, Any]]:
        """
        R√©cup√®re les donn√©es de funding format√©es pour le Scheduler.
        Calcule dynamiquement le temps restant √† partir des timestamps temps r√©el.
        
        Returns:
            Dict avec les donn√©es de funding format√©es pour chaque symbole
        """
        funding_data = {}
        selected_symbols = self.watchlist_manager.get_selected_symbols()
        self.logger.debug(f"[SCHEDULER] Symboles s√©lectionn√©s: {len(selected_symbols)}")
        
        for symbol in selected_symbols:
            funding_info = self._get_symbol_funding_data(symbol)
            if funding_info:
                funding_data[symbol] = funding_info
        
        self.logger.debug(f"[SCHEDULER] Donn√©es r√©cup√©r√©es: {len(funding_data)} symboles")
        return funding_data

    def _get_symbol_funding_data(self, symbol: str) -> Dict[str, Any]:
        """R√©cup√®re les donn√©es de funding pour un symbole sp√©cifique."""
        # R√©cup√©rer les donn√©es temps r√©el (mises √† jour via WebSocket)
        realtime_info = self.data_manager.storage.get_realtime_data(symbol)
        
        if realtime_info and realtime_info.get("next_funding_time"):
            # Calculer le temps restant √† partir du timestamp temps r√©el
            next_funding_timestamp = realtime_info["next_funding_time"]
            funding_time_str = self.watchlist_manager.calculate_funding_time_remaining(next_funding_timestamp)
            
            funding_data = {
                'next_funding_time': funding_time_str,  # Recalcul√© dynamiquement
                'funding_rate': realtime_info.get('funding_rate'),
                'volume_24h': realtime_info.get('volume24h')
            }
            self.logger.debug(f"[SCHEDULER] {symbol}: {funding_time_str} (temps r√©el)")
            return funding_data
        else:
            # Fallback sur les donn√©es originales si pas de donn√©es temps r√©el
            return self._get_fallback_funding_data(symbol)

    def _get_fallback_funding_data(self, symbol: str) -> Dict[str, Any]:
        """R√©cup√®re les donn√©es de funding en fallback depuis les donn√©es originales."""
        funding_obj = self.data_manager.storage.get_funding_data_object(symbol)
        if funding_obj:
            original_timestamp = self.data_manager.storage.get_original_funding_data(symbol)
            if original_timestamp:
                funding_time_str = self.watchlist_manager.calculate_funding_time_remaining(original_timestamp)
            else:
                funding_time_str = funding_obj.next_funding_time
                
            funding_data = {
                'next_funding_time': funding_time_str,
                'funding_rate': funding_obj.funding_rate,
                'volume_24h': funding_obj.volume_24h
            }
            self.logger.debug(f"[SCHEDULER] {symbol}: {funding_time_str} (fallback)")
            return funding_data
        else:
            self.logger.debug(f"[SCHEDULER] Aucune donn√©e pour {symbol}")
            return None

    async def _keep_bot_alive(self):
        """Maintient le bot en vie avec une boucle d'attente et monitoring m√©moire."""
        self.logger.info("üîÑ Bot op√©rationnel - surveillance continue...")

        try:
            while self.running:
                # V√©rifier que tous les composants principaux sont toujours actifs
                if not self._health_monitor.check_components_health(
                    self.monitoring_manager,
                    self.display_manager,
                    self.volatility_tracker,
                ):
                    self.logger.warning(
                        "‚ö†Ô∏è Un composant critique s'est arr√™t√©, red√©marrage..."
                    )
                    # Optionnel: red√©marrer les composants d√©faillants

                # Monitoring m√©moire p√©riodique
                if self._health_monitor.should_check_memory():
                    self._health_monitor.monitor_memory_usage()

                # Attendre avec v√©rification d'interruption
                await asyncio.sleep(1.0)

        except asyncio.CancelledError:
            self.logger.info("üõë Arr√™t demand√© par l'utilisateur")
            self.running = False
        except Exception as e:
            self.logger.error(f"‚ùå Erreur dans la boucle principale: {e}")
            self.running = False

    # ============================================================================
    # M√âTHODES DE STATUT ET ARR√äT
    # ============================================================================

    def get_status(self) -> Dict[str, Any]:
        """
        Retourne le statut actuel du bot.

        Returns:
            Dictionnaire contenant le statut du bot
        """
        return {
            "running": self.running,
            "uptime_seconds": time.time() - self.start_time,
            "testnet": self.testnet,
            "health_status": self._health_monitor.get_health_status(
                self.monitoring_manager,
                self.display_manager,
                self.volatility_tracker,
            ),
            "startup_stats": self._starter.get_startup_stats(
                self.data_manager
            ),
        }

    async def stop(self):
        """Arr√™te le bot de mani√®re propre via ShutdownManager."""
        self.logger.info("üõë Arr√™t du bot...")
        self.running = False

        # Utiliser ShutdownManager pour l'arr√™t centralis√©
        try:
            # Pr√©parer le dictionnaire des managers pour ShutdownManager
            managers = {
                "monitoring_manager": self.monitoring_manager,
                "display_manager": self.display_manager,
                "ws_manager": self.ws_manager,
                "volatility_tracker": self.volatility_tracker,
                "metrics_monitor": self.metrics_monitor,
            }

            # Arr√™ter les composants sp√©cialis√©s
            await self._stop_specialized_components()

            # Utiliser ShutdownManager pour l'arr√™t asynchrone
            # CORRECTIF : Utiliser await au lieu d'asyncio.run()
            # pour √©viter de cr√©er une nouvelle event loop imbriqu√©e
            await self._shutdown_manager.stop_all_managers_async(managers)

            self.logger.info("‚úÖ Bot arr√™t√© proprement via ShutdownManager")

        except Exception as e:
            self.logger.error(f"‚ùå Erreur lors de l'arr√™t: {e}")

    async def _stop_specialized_components(self):
        """Arr√™te les composants sp√©cialis√©s (PositionMonitor, FundingCloseManager)."""
        # Arr√™ter le PositionMonitor si actif
        if self.position_monitor:
            try:
                self.position_monitor.stop()
                self.logger.info("üîç PositionMonitor arr√™t√©")
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è Erreur arr√™t PositionMonitor: {e}")
        
        # Arr√™ter le FundingCloseManager si actif
        if self.funding_close_manager:
            try:
                self.funding_close_manager.stop()
                self.logger.info("üí∞ FundingCloseManager arr√™t√©")
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è Erreur arr√™t FundingCloseManager: {e}")


class AsyncBotRunner:
    """
    Lance le BotOrchestrator dans un event loop asyncio.
    """

    def __init__(self):
        self.logger = setup_logging()
        self.orchestrator = BotOrchestrator()
        self.running = True

    async def start(self):
        """D√©marre le bot de mani√®re asynchrone."""
        self.logger.info("D√©marrage du bot Bybit (mode asynchrone)...")
        try:
            # Configurer le signal handler pour l'arr√™t propre (Windows compatible)
            self._setup_signal_handlers()

            await self.orchestrator.start()
        except asyncio.CancelledError:
            self.logger.info("Bot arr√™t√© par annulation de t√¢che.")
        except Exception as e:
            self.logger.error(
                f"Erreur critique dans le runner asynchrone: {e}",
                exc_info=True,
            )
        finally:
            self.logger.info("Bot Bybit arr√™t√©.")

    def _setup_signal_handlers(self):
        """Configure les signal handlers pour l'arr√™t propre."""
        try:
            loop = asyncio.get_running_loop()
            for sig in (signal.SIGINT, signal.SIGTERM):
                loop.add_signal_handler(
                    sig, lambda: asyncio.create_task(self.stop())
                )
        except NotImplementedError:
            # Sur Windows, les signal handlers ne sont pas support√©s
            self.logger.debug(
                "Signal handlers non support√©s sur cette plateforme"
            )

    async def stop(self):
        """Arr√™te le bot de mani√®re asynchrone."""
        if self.running:
            self.running = False
            self.logger.info("Signal d'arr√™t re√ßu, arr√™t propre du bot...")
            # Utiliser la nouvelle m√©thode stop() du orchestrateur refactoris√©
            # CORRECTIF : Utiliser await car stop() est maintenant asynchrone
            await self.orchestrator.stop()
            # Annuler toutes les t√¢ches restantes pour permettre l'arr√™t de l'event loop
            await self._cancel_remaining_tasks()
            self.logger.info("Toutes les t√¢ches asynchrones ont √©t√© annul√©es.")
            sys.exit(0)  # Forcer la sortie apr√®s l'arr√™t propre

    async def _cancel_remaining_tasks(self):
        """Annule toutes les t√¢ches asyncio restantes."""
        tasks = [
            t
            for t in asyncio.all_tasks()
            if t is not asyncio.current_task()
        ]
        for task in tasks:
            task.cancel()
        await asyncio.gather(*tasks, return_exceptions=True)


async def main_async():
    # Installer le handler asyncio au point d'entr√©e principal
    install_asyncio_handler_if_needed()
    
    runner = AsyncBotRunner()
    await runner.start()


if __name__ == "__main__":
    try:
        asyncio.run(main_async())
    except KeyboardInterrupt:
        print("\nArr√™t demand√© par l'utilisateur (KeyboardInterrupt)")
    except Exception as e:
        print(f"Erreur inattendue: {e}")