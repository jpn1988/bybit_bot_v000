#!/usr/bin/env python3
"""
Gestionnaire de positions pour le bot Bybit.

Ce module surveille les positions ouvertes/ferm√©es via WebSocket priv√©
et notifie les autres composants via des callbacks.

Responsabilit√©s :
- Surveillance des positions via WebSocket priv√© (topic "position")
- D√©tection d'ouverture/fermeture de positions
- Callbacks pour notifier les changements d'√©tat
- Thread-safe avec gestion des erreurs
"""

import threading
import time
from typing import Optional, Callable, Dict, Any
from logging_setup import setup_logging
from ws_private import PrivateWSClient
from config import get_settings


class PositionMonitor:
    """
    Gestionnaire de surveillance des positions via WebSocket priv√©.
    
    Ce composant surveille les positions en temps r√©el et notifie
    les changements d'√©tat via des callbacks.
    """
    
    def __init__(
        self,
        testnet: bool = True,
        logger=None,
        on_position_opened: Optional[Callable[[str, Dict], None]] = None,
        on_position_closed: Optional[Callable[[str, Dict], None]] = None,
    ):
        """
        Initialise le moniteur de positions.
        
        Args:
            testnet: Utiliser le testnet (True) ou mainnet (False)
            logger: Logger pour les messages (optionnel)
            on_position_opened: Callback appel√© lors de l'ouverture d'une position
            on_position_closed: Callback appel√© lors de la fermeture d'une position
        """
        self.testnet = testnet
        self.logger = logger or setup_logging()
        
        # Callbacks
        self.on_position_opened = on_position_opened
        self.on_position_closed = on_position_closed
        
        # √âtat du moniteur
        self._running = False
        self._ws_client = None
        self._ws_thread = None
        
        # Tracking des positions actuelles
        self._current_positions = {}  # {symbol: position_data}
        
        # Thread safety
        self._lock = threading.Lock()
        
        # Configuration des cl√©s API
        settings = get_settings()
        self.api_key = settings.get("api_key")
        self.api_secret = settings.get("api_secret")
        
        if not self.api_key or not self.api_secret:
            self.logger.warning("‚ö†Ô∏è Cl√©s API manquantes - PositionMonitor d√©sactiv√©")
            self._enabled = False
        else:
            self._enabled = True
    
    def start(self):
        """
        D√©marre la surveillance des positions.
        
        Lance le WebSocket priv√© dans un thread s√©par√©.
        """
        if not self._enabled:
            self.logger.warning("‚ö†Ô∏è PositionMonitor d√©sactiv√© - cl√©s API manquantes")
            return
            
        if self._running:
            self.logger.warning("‚ö†Ô∏è PositionMonitor d√©j√† en cours d'ex√©cution")
            return
            
        try:
            # Cr√©er le client WebSocket priv√©
            self._ws_client = PrivateWSClient(
                testnet=self.testnet,
                api_key=self.api_key,
                api_secret=self.api_secret,
                channels=["position"],
                logger=self.logger,
            )
            
            # Configurer les callbacks
            self._ws_client.on_topic = self._handle_position_message
            self._ws_client.on_auth_success = self._on_auth_success
            self._ws_client.on_error = self._on_error
            self._ws_client.on_close = self._on_close
            
            # D√©marrer dans un thread s√©par√©
            self._ws_thread = threading.Thread(
                target=self._ws_runner,
                daemon=True,
                name="position_monitor_ws"
            )
            self._ws_thread.start()
            
            self._running = True
            self.logger.info("üîç PositionMonitor d√©marr√©")
            
        except Exception as e:
            self.logger.error(f"‚ùå Erreur d√©marrage PositionMonitor: {e}")
            self._running = False
    
    def stop(self):
        """
        Arr√™te la surveillance des positions.
        """
        if not self._running:
            return
            
        self._running = False
        
        # Arr√™ter le WebSocket
        if self._ws_client:
            try:
                self._ws_client.close()
            except Exception as e:
                self.logger.warning(f"‚ö†Ô∏è Erreur fermeture WebSocket: {e}")
        
        # Attendre la fin du thread
        if self._ws_thread and self._ws_thread.is_alive():
            try:
                self._ws_thread.join(timeout=5)
            except Exception:
                pass
        
        self.logger.info("üõë PositionMonitor arr√™t√©")
    
    def is_running(self) -> bool:
        """Retourne True si le moniteur est actif."""
        return self._running
    
    def has_open_positions(self) -> bool:
        """
        V√©rifie s'il y a des positions ouvertes.
        
        Returns:
            True si au moins une position est ouverte
        """
        with self._lock:
            return any(
                pos.get("size", "0") != "0" and float(pos.get("size", "0")) > 0
                for pos in self._current_positions.values()
            )
    
    def get_open_positions(self) -> Dict[str, Dict]:
        """
        Retourne les positions ouvertes.
        
        Returns:
            Dict des positions ouvertes {symbol: position_data}
        """
        with self._lock:
            return {
                symbol: pos for symbol, pos in self._current_positions.items()
                if pos.get("size", "0") != "0" and float(pos.get("size", "0")) > 0
            }
    
    def _ws_runner(self):
        """Runner pour le WebSocket priv√©."""
        if self._ws_client:
            try:
                self._ws_client.run()
            except Exception as e:
                if self._running:
                    self.logger.warning(f"‚ö†Ô∏è Erreur WebSocket PositionMonitor: {e}")
    
    def _handle_position_message(self, topic: str, data: Dict[str, Any]):
        """
        G√®re les messages de position re√ßus.
        
        Args:
            topic: Topic du message ("position")
            data: Donn√©es de position
        """
        try:
            if topic != "position":
                return
                
            # Parser les donn√©es de position
            positions = data.get("data", [])
            if not positions:
                return
            
            for position in positions:
                self._process_position_update(position)
                
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erreur traitement position: {e}")
    
    def _process_position_update(self, position_data: Dict[str, Any]):
        """
        Traite une mise √† jour de position.
        
        Args:
            position_data: Donn√©es de la position
        """
        try:
            symbol = position_data.get("symbol", "")
            size = position_data.get("size", "0")
            side = position_data.get("side", "")
            
            if not symbol:
                return
            
            # Convertir size en float pour comparaison
            try:
                size_float = float(size)
            except (ValueError, TypeError):
                size_float = 0.0
            
            with self._lock:
                # Mettre √† jour le cache des positions
                self._current_positions[symbol] = position_data
                
                # V√©rifier les changements d'√©tat
                was_open = self._was_position_open(symbol)
                is_now_open = size_float > 0
                
                if not was_open and is_now_open:
                    # Position ouverte
                    self.logger.info(f"üìà Position ouverte: {symbol} {side} {size}")
                    if self.on_position_opened:
                        try:
                            self.on_position_opened(symbol, position_data)
                        except Exception as e:
                            self.logger.warning(f"‚ö†Ô∏è Erreur callback position ouverte: {e}")
                
                elif was_open and not is_now_open:
                    # Position ferm√©e
                    self.logger.info(f"üìâ Position ferm√©e: {symbol}")
                    if self.on_position_closed:
                        try:
                            self.on_position_closed(symbol, position_data)
                        except Exception as e:
                            self.logger.warning(f"‚ö†Ô∏è Erreur callback position ferm√©e: {e}")
                
                # Nettoyer les positions ferm√©es du cache
                if not is_now_open and symbol in self._current_positions:
                    del self._current_positions[symbol]
                    
        except Exception as e:
            self.logger.warning(f"‚ö†Ô∏è Erreur traitement position {symbol}: {e}")
    
    def _was_position_open(self, symbol: str) -> bool:
        """
        V√©rifie si une position √©tait ouverte pr√©c√©demment.
        
        Args:
            symbol: Symbole √† v√©rifier
            
        Returns:
            True si la position √©tait ouverte
        """
        if symbol not in self._current_positions:
            return False
            
        old_size = self._current_positions[symbol].get("size", "0")
        try:
            return float(old_size) > 0
        except (ValueError, TypeError):
            return False
    
    def _on_auth_success(self):
        """Callback d'authentification r√©ussie."""
        self.logger.info("‚úÖ PositionMonitor authentifi√©")
    
    def _on_error(self, error):
        """Callback d'erreur WebSocket."""
        if self._running:
            self.logger.warning(f"‚ö†Ô∏è Erreur WebSocket PositionMonitor: {error}")
    
    def _on_close(self, close_status_code, close_msg):
        """Callback de fermeture WebSocket."""
        if self._running:
            self.logger.info("üîå WebSocket PositionMonitor ferm√©")
